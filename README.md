# spring-basic

## 2장. 스프링 핵심 원리 이해1 - 예제 만들기
- test 코드는 항상 test 폴더에 구현, test 폴더는 빌드 시 제외

## 3장. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용
- 좋은 객체 지향 설계 원칙
  - SRP(단일 책임 원칙)
    - 클래스는 하나의 책임만 가져야 함
    - 예시
      - 구현 객체를 생성하고 연결하는 책임을 AppConfig가 담당
      - 클라이언트 객체는 자신의 역할을 실행하는 것만 집중
  - DIP(의존 역전 원칙)
    - 고수준 모듈은 저수준 모듈에 의존해서는 안됨
    - 추상화에 의존해야 함
    - 예시
      - 클라이언트 코드는 인터페이스만으로는 아무것도 실행 불가
      - AppConfig가 객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 의존관계를 주입
      - DIP 원칙을 따르면서 문제도 해결
  - OCP(개방-폐쇄 원칙)
    - 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 함
    - 예시
      - 다형성 사용, 클라이언트가 DIP를 지킴
      - AppConfig에서만 클라이언트에 주입하는 객체 인스턴스를 바꿔주면 되기 때문에 OCP를 지킴
      - 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있음
  - Spring
    - IoC(제어의 역전) 컨테이너 또는 DI(의존성 주입) 컨테이너
      - 기존 프로그램에서는 구현 객체가 클라이언트 코드를 직접 생성하고 연결
      - AppConfig는 Ioc 컨테이너 또는 DI 컨테이너 역할로, 프로그램 제어 흐름을 가져감
      - 이처럼 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라고 함
    - 동적인 객체 인스턴스 의존 관계
      - 런타임에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입
      - 장점
        - 이를 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스 변경 가능
        - 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있음
    - ApplicationContext
      - 기존 DI를 위해 사용하던 AppConfig를 스프링 컨테이너인 ApplicationContext로 변경
      - 스프링 컨테이너는 @Configuration, @Bean 애노테이션을 사용해 객체를 생성하고 관리
      - @Configuration
        - AppConfig 클래스에 @Configuration 애노테이션을 추가하면 스프링 컨테이너가 해당 클래스를 설정 정보로 인식
      - @Bean
        - @Bean 애노테이션이 붙은 메서드는 스프링 컨테이너가 관리하는 빈(Bean)으로 등록됨