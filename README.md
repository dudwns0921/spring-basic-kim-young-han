# spring-basic

## 2장. 스프링 핵심 원리 이해1 - 예제 만들기

- test 코드는 항상 test 폴더에 구현, test 폴더는 빌드 시 제외

## 3장. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

- 좋은 객체 지향 설계 원칙
    - SRP(단일 책임 원칙)
        - 클래스는 하나의 책임만 가져야 함
        - 예시
            - 구현 객체를 생성하고 연결하는 책임을 AppConfig가 담당
            - 클라이언트 객체는 자신의 역할을 실행하는 것만 집중
    - DIP(의존 역전 원칙)
        - 고수준 모듈은 저수준 모듈에 의존해서는 안됨
        - 추상화에 의존해야 함
        - 예시
            - 클라이언트 코드는 인터페이스만으로는 아무것도 실행 불가
            - AppConfig가 객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 의존관계를 주입
            - DIP 원칙을 따르면서 문제도 해결
    - OCP(개방-폐쇄 원칙)
        - 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 함
        - 예시
            - 다형성 사용, 클라이언트가 DIP를 지킴
            - AppConfig에서만 클라이언트에 주입하는 객체 인스턴스를 바꿔주면 되기 때문에 OCP를 지킴
            - 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있음
- Spring
    - IoC(제어의 역전) 컨테이너 또는 DI(의존성 주입) 컨테이너
        - 기존 프로그램에서는 구현 객체가 클라이언트 코드를 직접 생성하고 연결
        - AppConfig는 Ioc 컨테이너 또는 DI 컨테이너 역할로, 프로그램 제어 흐름을 가져감
        - 이처럼 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라고 함
    - 동적인 객체 인스턴스 의존 관계
        - 런타임에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입
        - 장점
            - 이를 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스 변경 가능
            - 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있음
    - ApplicationContext
        - 기존 DI를 위해 사용하던 AppConfig를 스프링 컨테이너인 ApplicationContext로 변경
        - 스프링 컨테이너는 @Configuration, @Bean 애노테이션을 사용해 객체를 생성하고 관리
        - @Configuration
            - AppConfig 클래스에 @Configuration 애노테이션을 추가하면 스프링 컨테이너가 해당 클래스를 설정 정보로 인식
        - @Bean
            - @Bean 애노테이션이 붙은 메서드는 스프링 컨테이너가 관리하는 빈(Bean)으로 등록됨

## 4장. 스프링 컨테이너

- 스프링 컨테이너 생성
    - ApplicationContext는 인터페이스이며 이를 스프링 컨테이너라고 함
    - 스프링 컨테이너는 XML, 자바 코드, 애노테이션 등 다양한 방법으로 생성 가능
    - 스프링 컨테이너를 생성할 때는 구성 정보를 제공해야 함
    - 빈 이름은 메서드 이름을 사용하며, 빈 이름은 항상 유일해야 함
- 스프링 빈 조회 - 기본
    - getBean() 메서드를 사용
        - 메서드명
            - 이름이 없으면 예외 발생
        - 타입
            - 동일한 타입이 둘 이상이면 오류 발생, 이 때는 빈 이름 지정
            - getBeansOfType() 메서드를 사용하면 해당 타입의 모든 빈을 조회 가능
        - 구체 타입
- 스프링 빈 조회 - 상속 관계
    - 부모 타입으로 조회하면, 자식 타입도 함께 조회
    - 자식이 둘 이상이면 오류 발생, 이 때 빈 이름 지정하면 조회 가능
- BeanFactory와 ApplicationContext
    - BeanFactory
        - 스프링 컨테이너의 최상위 인터페이스
        - 스프링 빈을 관리하고 조회하는 역할
        - getBean() 메서드를 사용해 빈을 조회
    - ApplicationContext
        - BeanFactory를 상속받은 인터페이스
        - BeanFactory의 모든 기능을 포함하면서, 추가적인 기능을 제공
        - 국제화를 위한 메시지 소스, 환경 변수, 애플리케이션 이벤트, 편리한 리소스 로딩 등 다양한 기능을 제공
- BeanDefinition
    - BeanDefinition은 스프링 컨테이너가 관리하는 빈의 메타데이터
    - BeanDefinition는 추상화를 통해 다양한 설정 형식을 지원
    - 역할과 구현을 개념적으로 나눈 것으로 xml, 자바 코드, 애노테이션을 통해 BeanDefinition을 정의할 수 있음
    - 스프링 컨테이너는 BeanDefinition을 기반으로 빈을 생성하고 관리

## 5장. 싱글톤 컨테이너

- 웹 애플리케이션과 싱글톤
    - 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생
    - 웹 애플리케이션의 경우 보통 여러 고객이 동시에 요청
    - 스프링은 싱글톤 컨테이너를 사용해 객체를 하나만 생성하고 공유
- 싱글톤 패턴
    - 클래스의 인스턴스를 오직 하나만 생성하고, 이 인스턴스를 공유하는 패턴
    - static 영역에 객체 인스턴스를 미리 하나 생성해서 올려둠
    - 오직 getInstance() 메서드를 통해서만 객체 인스턴스를 반환
    - 생성자를 private으로 선언해서 외부에서 객체 인스턴스를 생성하지 못하도록 함
    - 유연성이 떨어진다는 단점이 있어 안티패턴으로 불리기도 함
- 싱글톤 컨테이너
    - 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤으로 관리
        - 싱글톤 패턴은 클래스 내부에 인스턴스를 직접 생성하고 관리
        - 스프링 컨테이너는 객체 생성과 관리를 외부에서 하므로 다양한 구현체로 교체하거나 테스트용 객체를 주입하는 등 유연하게 관리 가능
    - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 객체를 싱글톤으로 관리
    - 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 함
    - 이로 인해 싱글톤 패턴의 모든 단점을 해결하면서 싱글톤 객체를 관리할 수 있음
- 싱글톤 방식의 주의점
    - 무상태로 설계해야 함
        - 특정 클라이언트에 의존적인 필드가 있으면 안됨
        - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됨
        - 필드 대신에 자바에서 공유되지 않는 지역 변수, 파라미터, ThreadLocal 등을 사용해야 함
    - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있음
- @Configuration과 싱글톤
    - @Configuration 애노테이션이 붙은 클래스는 스프링 컨테이너가 관리하는 빈으로 등록됨
    - 스프링 빈을 조회해보면 xxxCGLIB라는 객체가 반환됨
    - CGLIB는 바이트코드 조작 라이브러리로, @Configuration이 붙은 클래스는 CGLIB를 사용해 설정 클래스를 상속받는 프록시 객체를 만들고, 이 프록시를 통해
      @Bean 메소드 호출을 가로채서 싱글톤을 보장함
    - @Configuration 없이 @Bean 애노테이션만 사용하면 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않음