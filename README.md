# spring-basic

## 2장. 스프링 핵심 원리 이해1 - 예제 만들기

- test 코드는 항상 test 폴더에 구현, test 폴더는 빌드 시 제외

## 3장. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

- 좋은 객체 지향 설계 원칙
    - SRP(단일 책임 원칙)
        - 클래스는 하나의 책임만 가져야 함
        - 예시
            - 구현 객체를 생성하고 연결하는 책임을 AppConfig가 담당
            - 클라이언트 객체는 자신의 역할을 실행하는 것만 집중
    - DIP(의존 역전 원칙)
        - 고수준 모듈은 저수준 모듈에 의존해서는 안됨
        - 추상화에 의존해야 함
        - 예시
            - 클라이언트 코드는 인터페이스만으로는 아무것도 실행 불가
            - AppConfig가 객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 의존관계를 주입
            - DIP 원칙을 따르면서 문제도 해결
    - OCP(개방-폐쇄 원칙)
        - 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 함
        - 예시
            - 다형성 사용, 클라이언트가 DIP를 지킴
            - AppConfig에서만 클라이언트에 주입하는 객체 인스턴스를 바꿔주면 되기 때문에 OCP를 지킴
            - 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있음
- Spring
    - IoC(제어의 역전) 컨테이너 또는 DI(의존성 주입) 컨테이너
        - 기존 프로그램에서는 구현 객체가 클라이언트 코드를 직접 생성하고 연결
        - AppConfig는 Ioc 컨테이너 또는 DI 컨테이너 역할로, 프로그램 제어 흐름을 가져감
        - 이처럼 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라고 함
    - 동적인 객체 인스턴스 의존 관계
        - 런타임에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입
        - 장점
            - 이를 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스 변경 가능
            - 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있음
    - ApplicationContext
        - 기존 DI를 위해 사용하던 AppConfig를 스프링 컨테이너인 ApplicationContext로 변경
        - 스프링 컨테이너는 @Configuration, @Bean 애노테이션을 사용해 객체를 생성하고 관리
        - @Configuration
            - AppConfig 클래스에 @Configuration 애노테이션을 추가하면 스프링 컨테이너가 해당 클래스를 설정 정보로 인식
        - @Bean
            - @Bean 애노테이션이 붙은 메서드는 스프링 컨테이너가 관리하는 빈(Bean)으로 등록됨

## 4장. 스프링 컨테이너

- 스프링 컨테이너 생성
    - ApplicationContext는 인터페이스이며 이를 스프링 컨테이너라고 함
    - 스프링 컨테이너는 XML, 자바 코드, 애노테이션 등 다양한 방법으로 생성 가능
    - 스프링 컨테이너를 생성할 때는 구성 정보를 제공해야 함
    - 빈 이름은 메서드 이름을 사용하며, 빈 이름은 항상 유일해야 함
- 스프링 빈 조회 - 기본
    - getBean() 메서드를 사용
        - 메서드명
            - 이름이 없으면 예외 발생
        - 타입
            - 동일한 타입이 둘 이상이면 오류 발생, 이 때는 빈 이름 지정
            - getBeansOfType() 메서드를 사용하면 해당 타입의 모든 빈을 조회 가능
        - 구체 타입
- 스프링 빈 조회 - 상속 관계
    - 부모 타입으로 조회하면, 자식 타입도 함께 조회
    - 자식이 둘 이상이면 오류 발생, 이 때 빈 이름 지정하면 조회 가능
- BeanFactory와 ApplicationContext
    - BeanFactory
        - 스프링 컨테이너의 최상위 인터페이스
        - 스프링 빈을 관리하고 조회하는 역할
        - getBean() 메서드를 사용해 빈을 조회
    - ApplicationContext
        - BeanFactory를 상속받은 인터페이스
        - BeanFactory의 모든 기능을 포함하면서, 추가적인 기능을 제공
        - 국제화를 위한 메시지 소스, 환경 변수, 애플리케이션 이벤트, 편리한 리소스 로딩 등 다양한 기능을 제공
- BeanDefinition
    - BeanDefinition은 스프링 컨테이너가 관리하는 빈의 메타데이터
    - BeanDefinition는 추상화를 통해 다양한 설정 형식을 지원
    - 역할과 구현을 개념적으로 나눈 것으로 xml, 자바 코드, 애노테이션을 통해 BeanDefinition을 정의할 수 있음
    - 스프링 컨테이너는 BeanDefinition을 기반으로 빈을 생성하고 관리

## 5장. 싱글톤 컨테이너

- 웹 애플리케이션과 싱글톤
    - 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생
    - 웹 애플리케이션의 경우 보통 여러 고객이 동시에 요청
    - 스프링은 싱글톤 컨테이너를 사용해 객체를 하나만 생성하고 공유
- 싱글톤 패턴
    - 클래스의 인스턴스를 오직 하나만 생성하고, 이 인스턴스를 공유하는 패턴
    - static 영역에 객체 인스턴스를 미리 하나 생성해서 올려둠
    - 오직 getInstance() 메서드를 통해서만 객체 인스턴스를 반환
    - 생성자를 private으로 선언해서 외부에서 객체 인스턴스를 생성하지 못하도록 함
    - 유연성이 떨어진다는 단점이 있어 안티패턴으로 불리기도 함
- 싱글톤 컨테이너
    - 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤으로 관리
        - 싱글톤 패턴은 클래스 내부에 인스턴스를 직접 생성하고 관리
        - 스프링 컨테이너는 객체 생성과 관리를 외부에서 하므로 다양한 구현체로 교체하거나 테스트용 객체를 주입하는 등 유연하게 관리 가능
    - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 객체를 싱글톤으로 관리
    - 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 함
    - 이로 인해 싱글톤 패턴의 모든 단점을 해결하면서 싱글톤 객체를 관리할 수 있음
- 싱글톤 방식의 주의점
    - 무상태로 설계해야 함
        - 특정 클라이언트에 의존적인 필드가 있으면 안됨
        - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됨
        - 필드 대신에 자바에서 공유되지 않는 지역 변수, 파라미터, ThreadLocal 등을 사용해야 함
    - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있음
- @Configuration과 싱글톤
    - @Configuration 애노테이션이 붙은 클래스는 스프링 컨테이너가 관리하는 빈으로 등록됨
    - 스프링 빈을 조회해보면 xxxCGLIB라는 객체가 반환됨
    - CGLIB는 바이트코드 조작 라이브러리로, @Configuration이 붙은 클래스는 CGLIB를 사용해 설정 클래스를 상속받는 프록시 객체를 만들고, 이 프록시를 통해
      @Bean 메소드 호출을 가로채서 싱글톤을 보장함
    - @Configuration 없이 @Bean 애노테이션만 사용하면 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않음

## 6장. 컴포넌트 스캔

- 컴포넌트 스캔과 의존관계 자동 주입
    - 등록해야 할 스프링 빈이 많아질 때 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능 제공
    - @ComponentScan 애노테이션을 사용해 컴포넌트 스캔을 활성화
    - @ComponentScan 애노테이션은 @Component 애노테이션이 붙은 클래스를 스캔해서 빈으로 등록
    - @Configuration에도 @Component 애노테이션이 붙어 있어 컴포넌트 스캔 대상이 됨
    - @Autowired 애노테이션을 사용해 의존관계를 자동으로 주입
    - 이 때 의존관계를 주입하기 위한 클래스는 @Component 애노테이션이 붙어 있어야 함
- 탐색 위치와 기본 스캔 대상
    - basePackages
        - 위 속성을 사용해 컴포넌트 스캔을 시작할 패키지를 지정
        - 해당 패키지를 기준으로 하위 패키지까지 모두 탐색
        - 지정하지 않을 경우 @ComponentScan이 붙은 클래스의 패키지를 기준으로 탐색
    - 관례
        - 패키지 위치를 지정하지 않고 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것
        - 최근 스프링 부트도 이 방법을 기본으로 제공
    - 컴포넌트 스캔 기본 대상
        - @Component, @Controller, @Service, @Repository, @Configuration 애노테이션이 붙은 클래스
        - 애노테이션은 자바가 아닌 스프링이 지원하는 기능
    - Filter
        - Filtertype
            - ANNOTATION
                - 기본값
            - ASSIGNABLE_TYPE
            - ASPECTJ
            - REGEX
            - CUSTOM
        - includeFilters
            - 컴포넌트 스캔 대상에 포함할 애노테이션을 지정
        - excludeFilters
            - 컴포넌트 스캔 대상에서 제외할 애노테이션을 지정
        - 굳이 필터 기능을 사용하기 보다는 스프링 기본 설정에 따라 컴포넌트 스캔을 사용하는 것이 좋음
- 중복 등록과 충돌
    - 컴포넌트 스캔 대상에 동일한 빈 이름이 중복 등록되면 오류 발생
    - 수동 빈 등록과 자동 빈 등록이 충돌하는 경우 수동 빈 등록이 우선시됨
    - 최근에는 수동 빈 등록과 자동 빈 등록 충돌이 발생하면 오류가 발생하도록 변경됨

## 7장. 의존관계 자동 주입

- 다양한 의존관계 주입 방법
    - 4가지 방법
        - 생성자 주입
        - 수정자 주입
        - 필드 주입
        - 일반 메서드 주입
    - 생성자 주입
        - 생성자 호출 시점에 딱 1번만 호출되는 것이 보장
        - 불변, 필수 의존관계에 사용
        - 생성자가 1개만 있으면 @Autowired 애노테이션 생략 가능
        - 생성자 시점이기 때문에 사실 빈을 등록할 때 의존관계도 함께 주입됨
    - setter 메서드
        - xml 방식에서는 기본 생성자로 먼저 객체를 생성한 뒤, setter 메서드를 통해 의존관계를 주입
    - 필드 주입
        - 안티패턴으로 권장되지 않음
        - DI 프레임워크가 없으면 테스트하기 어려움
    - 일반 메서드 주입
        - 어떤 메서드에도 @Autowired 애노테이션을 붙이면 일반 메서드 주입이 됨
- 옵션 처리
    - 주입할 스프링 빈이 없을 때 동작해야 할 때
    - @Autowired만 사용하면 스프링 빈이 없으면 오류 발생
    - 자동 주입 대상 옵션 처리 방법
        - requied=false
            - @Autowired(required=false)로 설정하면 메서드 자체가 호출되지 않음
        - @Nullable
            - 스프링 빈이 없으면 null로 주입
        - Optional
            - Optional<BeanType>으로 설정하면 스프링 빈이 없을 때 Optional.empty()로 주입
- 생성자 주입 선택 이유
    - 불변
        - 대부분의 의존 관계 주입은 한 번 일어나면 애플리케이션 종료 시점까지 변경할 일이 없음
    - 누락
        - 수정자 주입을 사용할 경우, 의존관계가 누락되면 런타임 오류가 발생
        - 생성자 주입을 사용할 경우, 컴파일 시점에 의존관계가 누락되면 오류 발생
        - 따라서 생성자 주입을 사용해야 컴파일 시점에 의존관계가 누락되었는지 확인 가능해서 안전함
        - 컴파일 오류가 가장 빠르고 좋은 오류
    - 프레임워크에 의존하지 않고 순수한 자바 언어 특징을 잘 살리는 방법
    - 기본으로 생성자 주입을 사용, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 됨
    - 생성자 주입과 수정자 주입을 동시에 사용 가능
- 롬복과 최신 트렌드
    - 롬복
        - 적용 방법
            - build.gradle에 롬복 라이브러리 추가
            - IDE에 롬복 플러그인 설치
        - @RequiredArgsConstructor 애노테이션을 사용해 생성자 주입을 간편하게 구현
- 조회 빈이 2개 이상
    - 해결 방법
        - @Autowired 필드 명 매칭
            - 여러 빈이 있을 경우, 필드 이름, 파라미터 이름으로 빈 이름 추가 매칭
        - @Qualifier
            - @Qualifier 애노테이션 찾아 매칭
            - @Qualifier 애노테이션이 없으면 빈 이름으로 매칭
            - 예외 발생
            - 권장되는 건 @Qualifier는 @Qualifier을 찾는 용도로만 사용하는 것이 좋음
        - @Primary 사용
            - 여러 빈 매칭 시 @Primary 애노테이션이 붙은 빈을 우선적으로 사용
    - 우선순위
        - @Qualifier > @Primary > 필드명, 파라미터명
- 조회한 빈이 모두 필요할 때
    - 의존관계를 주입받는 필드를 Map, List로 선언
    - 주입 분석
        - Map<String, DiscountPolicy> : map의 키에 스프링 빈의 이름을 넣어주고 그 값으로 DiscountPolicy 타입으로 조회한 모든 스프링
          빈을 담아준다.
        - List<DiscountPolicy> : DiscountPolicy 타입으로 조회한 모든 스프링 빈을 담아준다.
        - 만약 해당하는 타입의 스프링 빈이 없으면, 빈 컬렉션이나 Map을 주입한다.
- 자동, 수동의 올바른 실무 운영 기준
    - 애플리케이션 구분
        - 업무 로직 빈
            - 컨트롤러, 비즈니스 로직이 있는 서비스, 데이터 계층 로직을 처리하는 리포지토리 등
        - 기술 지원 빈
            - 기술적인 문제나 공통 관심사 처리할 때 사용
            - 데이터베이스 연결이나 고통 로그 처리
    - 업무 로직은 자동 기능 적극 활용, 기술 지원 빈은 수동으로 등록
    - 그외 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보기

## 8장. 빈 생명주기 콜백

- 빈 생명주기 콜백 시장
    - 스프링 빈의 생명주기
        1. 스프링 컨테이너 생성
        2. 스프링 빈 생성
        3. 의존관계 주입
        4. 초기화 콜백
        5. 사용
        6. 소멸전 콜백
        7. 스프링 종료
    - 객체의 생성과 초기화는 분리하는 것이 좋음
        - 초기화에서 무거운 동작들, 외부 커넥션 등을 수행할 경우에만
    - 스프링이 지원하는 3가지 생명주기 콜백
        - InitializingBean 인터페이스
            - 스프링에 너무 의존적으로 됨
        - 설정 정보에 초기화 메서드, 종료 메서드 지정
            - 메서드 이름 자유롭게 사용 가능
            - 스프링 빈이 스프링 코드에 의존적이지 않음
            - 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드 적용 가능
        - @PostConstruct, @PreDestroy 애노테이션
            - 최신 스프링에서 가장 권장하는 방법
            - 애노테이션 하나만 붙이면 됨
            - 스프링에 종속된 기술이 아니라, 자바 표준이라 다른 컨테이너에서도 도작
            - 외부 라이브러리에 적용이 불가한데, 이 떄는 @Bean(initMethod, destroyMethod) 설정을 사용

## 9장. 빈 스코프

- 빈 스코프란
    - 빈이 존재할 수 있는 범위
    - 지원하는 스코프
        - 싱글톤
            - 기본 스코프, 스프링 컨테이너 생성부터 종료 시점까지 유지
        - 프로토타입
            - 빈의 생성과 의존관계 주입까지만 스프링이 관리
        - 웹 관련 스코프
            - request
                - 웹 요청이 들어오고 나갈 때까지 유지
            - session
                - 웹 세션이 생성되고 종료될 때까지 유지
            - application
                - 서블릿 컨텍스트와 같은 범위로 유지
- 프로토타입 스코프
    - 싱글톤 빈 요청
        - 스프링 컨테이너에 빈 요청
        - 본인이 관리하는 빈 반환
        - 같은 요청이 와도 동일한 빈 반환
    - 프로토타입 빈 요청
    - 스프링 컨테이너에 빈 요청
        - 스프링 컨테이너가 프로토타입 빈을 생성하고 의존관계 주입
        - 스프링 컨테이너가 프로토타입 빈을 반환
        - 이후 프로토타입 빈은 스프링 컨테이너가 관리하지 않음
            - 이로 인해 종료 메서드가 호출되지 않음
        - 프로토타입 빈은 매번 새로 생성됨
- 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
- 프로토타입 빈을 싱글톤 빈에서 사용
    - 싱글톤 빈이 내부에 가지고 있는 프로토타입 빈은 과거에 주입이 끝난 빈
    - 싱글톤 빈의 주입 시점에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성된 것이지 사용할 때마다 새로 생성되는 것이 아님
- Provider 사용하기
    - 지정한 빈을 컨테이너에서 대신 찾아주는 DL(Dependency Lookup) 기능을 제공하는 것이 ObjectProvider
- 프로토타입 빈 언제 써야하나?
    - 사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요할 때 프로토타입 빈 사용
    - 실제로는 싱글톤 빈으로 대부분 문제 해결 가능해 사용할 일이 많지 않음
- 웹 스코프
    - 웹 환경에서만 동작
    - 스프링이 해당 스코프의 종료 시점까지 관리, 종료 메서드 호출됨
    - request: HTTP 요청이 들어오고 나갈 때까지 유지, HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리됨
    - spring-boot-starter-web 라이브러리
        - 위 라이브러리가 있으면 스프링 부트는 내장 톰캣 서버를 활용해서 웹 서버와 스프링을 함께 실행시킴
    - 공통 처리가 필요한 경우에는 스프링 인터셉터나 서블릿 필터같은 곳 활용하기
    - request 빈은 싱글톤 빈에서 의존 관계 주입 시 오류가 발생
- 스코프와 Provider
    - ObjectProvider를 사용하면 request 스코프 빈을 싱글톤 빈에서 사용할 수 있음
    - ObjectProvider는 스프링이 제공하는 지연 주입 도구
    - getObject()를 호출하는 시점까지 빈을 찾지 않고 기다림
    - 실제로 getObject()가 호출될 때, 현재 컨텍스트 (즉, HTTP 요청이 존재하는 시점)에서 해당 스코프의 빈을 가져옴
    - 따라서 request 스코프의 빈을 안전하게 사용 가능
- 스코프와 프록시
    - CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입
    - 가짜 프록시 객체는 요청이 오면 그 때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있음
    - 가짜 포록시 객체는 실제 request 스코프와는 관계가 없음. 그냥 가짜고, 내부에 단순한 위임 로직만 있고 싱글톤처럼 동작
    - 결국 Provider든 프록시든 진짜 객체 조회를 꼭 필요한 시점까지 지연처리하는 것이 핵심 아이디어

